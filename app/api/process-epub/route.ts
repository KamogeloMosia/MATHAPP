import { type NextRequest, NextResponse } from "next/server"
import clientPromise from "@/lib/mongodb"
import { generateText } from "ai"
import { google } from "@ai-sdk/google" // Import Google AI SDK
import { prompts } from "@/lib/ai-prompts"
import { parseEpub } from "@/lib/epub-parser" // Conceptual parser
import type { EpubContent } from "@/lib/types"

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const file = formData.get("epubFile") as Blob

    const parsedEpub = await parseEpub(file)

    if (!parsedEpub || parsedEpub.chapters.length === 0) {
      return NextResponse.json({ error: "Failed to parse EPUB or no content found." }, { status: 400 })
    }

    const client = await clientPromise
    const db = client.db("stewart-calculus")
    const epubContentCollection = db.collection<EpubContent>("epub_content")

    const processedChapters: EpubContent[] = []

    for (const chapter of parsedEpub.chapters) {
      // Generate summary for the chapter using Gemini
      const summaryPrompt = prompts.epubContent.summary(chapter.title, chapter.content)
      const { text: generatedSummary } = await generateText({
        model: google("gemini-pro"), // Use Gemini for summary
        prompt: summaryPrompt,
        temperature: 0.5,
      })

      // Generate questions for the chapter using Gemini
      const questionsPrompt = prompts.epubContent.questions(chapter.title, chapter.content)
      const { text: generatedQuestionsText } = await generateText({
        model: google("gemini-pro"), // Use Gemini for questions
        prompt: questionsPrompt,
        temperature: 0.7,
      })

      let generatedQuestions = []
      try {
        const jsonMatch = generatedQuestionsText.match(/\[[\s\S]*\]/)
        if (jsonMatch) {
          generatedQuestions = JSON.parse(jsonMatch[0])
        }
      } catch (parseError) {
        console.error("Failed to parse generated questions JSON:", parseError)
      }

      const epubChapterContent: EpubContent = {
        epubTitle: parsedEpub.title,
        chapterTitle: chapter.title,
        chapterContent: chapter.content, // Store raw content for reference
        generatedSummary: generatedSummary,
        generatedQuestions: generatedQuestions.map((q: any) => ({
          ...q,
          created_by: "gemini", // Mark as generated by Gemini
        })),
        createdAt: new Date(),
        updatedAt: new Date(),
      }

      processedChapters.push(epubChapterContent)
    }

    // Save all processed chapters to MongoDB
    if (processedChapters.length > 0) {
      await epubContentCollection.insertMany(processedChapters)
    }

    return NextResponse.json({
      success: true,
      message: `Successfully processed EPUB "${parsedEpub.title}" with ${processedChapters.length} chapters.`,
      processedChapters: processedChapters.map((c) => ({
        epubTitle: c.epubTitle,
        chapterTitle: c.chapterTitle,
        summaryLength: c.generatedSummary.length,
        questionCount: c.generatedQuestions.length,
      })),
    })
  } catch (error) {
    console.error("Error processing EPUB:", error)
    return NextResponse.json({ error: "Internal server error during EPUB processing." }, { status: 500 })
  }
}
